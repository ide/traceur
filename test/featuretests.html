<!DOCTYPE html>
<!--

// Copyright 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

-->
<html>
<head>
<title></title>
<script src="../third_party/closure-library/closure/goog/base.js"></script>
<script>
goog.require('goog.testing.jsunit');
</script>
<script src="../src/traceur.js"></script>

<script src="feature/Classes/ClassMembers.js" type="text/traceur"></script>
<script src="feature/Classes/Constructor.js" type="text/traceur"></script>
<script src="feature/Classes/ConstructorChaining.js" type="text/traceur"></script>
<script src="feature/Classes/ConstructorReturn.js" type="text/traceur"></script>
<script src="feature/Classes/DerivedButton.js" type="text/traceur"></script>
<script src="feature/Classes/DeriveFromObject.js" type="text/traceur"></script>
<script src="feature/Classes/EmptyClass.js" type="text/traceur"></script>
<script src="feature/Classes/FieldInheritance.js" type="text/traceur"></script>
<script src="feature/Classes/FieldInitializers.js" type="text/traceur"></script>
<script src="feature/Classes/FieldInitializersAndConstructorParameters.js" type="text/traceur"></script>
<script src="feature/Classes/FieldInitializersAndInheritance.js" type="text/traceur"></script>
<script src="feature/Classes/FieldLookup.js" type="text/traceur"></script>
<script src="feature/Classes/Fields.js" type="text/traceur"></script>
<script src="feature/Classes/Getters.js" type="text/traceur"></script>
<script src="feature/Classes/Inheritance.js" type="text/traceur"></script>
<script src="feature/Classes/InheritanceFromMemberExpression.js" type="text/traceur"></script>
<script src="feature/Classes/InheritanceFromNonclass.js" type="text/traceur"></script>
<script src="feature/Classes/InheritanceNameBinding.js" type="text/traceur"></script>
<script src="feature/Classes/Method.js" type="text/traceur"></script>
<script src="feature/Classes/MethodLookup.js" type="text/traceur"></script>
<script src="feature/Classes/MethodInheritance.js" type="text/traceur"></script>
<script src="feature/Classes/NameBinding.js" type="text/traceur"></script>
<script src="feature/Classes/PropertyAccessors.js" type="text/traceur"></script>
<script src="feature/Classes/SimpleConst.js" type="text/traceur"></script>
<script src="feature/Classes/SimpleSuper.js" type="text/traceur"></script>
<script src="feature/Classes/StaticMembers.js" type="text/traceur"></script>
<script src="feature/Classes/SuperChaining.js" type="text/traceur"></script>
<script src="feature/Classes/SuperMissing.js" type="text/traceur"></script>
<script src="feature/Traits/DiamondMixin.js" type="text/traceur"></script>
<script src="feature/Traits/Error_DeriveFromTrait.js" type="text/traceur"></script>
<script src="feature/Traits/PropertyTrait.js" type="text/traceur"></script>
<script src="feature/Traits/RequiresAndInheritance.js" type="text/traceur"></script>
<script src="feature/Traits/RequiresMember.js" type="text/traceur"></script>
<script src="feature/Traits/SimpleTrait.js" type="text/traceur"></script>
<script src="feature/Traits/TraitMixin.js" type="text/traceur"></script>
</head>
<body>
<script>

/**
 * Given a path like "feature/Foo/Bar" makes a function name to test that
 * feature: "testFooBar".
 */
function makeTestName(path) {
  var pathStart = 'feature/';
  var start = path.indexOf(pathStart) + pathStart.length;

  var name = path.substring(start);
  name = name.replace('/', '');
  name = name.replace('.js', '');

  return 'test' + name;
}

// Define some helper methods that the feature scripts can use:

function assertNoOwnProperties(o) {
  var m = Object.getOwnPropertyNames(o);
  if (m.length) {
    fail('Unexpected members found:' + m.join(', '));
  }
}

function assertHasOwnProperty(o) {
  var args = Array.prototype.slice.call(arguments, 1);
  for (var i = 0; i < args.length; i ++) {
    var m = args[i];
    if (!o.hasOwnProperty(m)) {
      fail('Expected member ' + m + ' not found.');
    }
  }
}

function assertLacksOwnProperty(o) {
  var args = Array.prototype.slice.call(arguments, 1);
  for (var i = 0; i < args.length; i ++) {
    var m = args[i];
    if (o.hasOwnProperty(m)) {
      fail('Unxpected member ' + m + ' found.');
    }
  }
}


function evalScript(scriptElement) {
  var source;
  var name;
  if (scriptElement.src) {
    name = scriptElement.src;
    var xhr = new XMLHttpRequest();
    xhr.open('GET', scriptElement.src, false);
    xhr.send();
    source = xhr.responseText;
  } else {
    name = 'inline-script';
    source = scriptElement.textContent;
  }

  // For each Traceur .js file, we'll create a top-level "test___" function
  // that compiles and evaluates it. JsUnit will then find and run those
  // functions for us.
  // We eval each file in the scope of its own function so we don't have to
  // worry about name clashes across the different feature scripts.
  var testName = makeTestName(name);
  window[testName] = function() {
    var errors = new traceur.util.ErrorReporter();
    var sourceFile = new traceur.syntax.SourceFile(name, source);
    var tree = traceur.codegeneration.Compiler.compileFile(errors, sourceFile);
    var code = traceur.codegeneration.ParseTreeWriter.write(tree);

    if (source.indexOf('// Should not compile') == 0) {
      // Script should not compile.
      assertTrue('Expected error compiling ' + name + ', but got none.',
          errors.hadError());
    } else {
      assertFalse('Error compiling ' + name + '.', errors.hadError());

      // Script compiled, so run it.
      eval(code);
    }
  }
}

function evalAllScripts() {
  var scripts = document.querySelectorAll('script[type="text/traceur"]');
  Array.prototype.forEach.call(scripts, evalScript);
}

evalAllScripts();

</script>
</body>
</html>
