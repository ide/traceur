<!DOCTYPE html>
<!--

// Copyright 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

-->
<html>
<head>
<title></title>
<script src="../../../third_party/closure-library/closure/goog/base.js"></script>
<script>
// NOTE: base.js and all goog.require statements must be in JS script blocks
// NOTE: because they use document.write to add new script tags in place
goog.require('goog.testing.jsunit');
</script>
<script src="../../traceur.js"></script>

<script src="ParseTreeType.js"></script>
<script src="ParseTree.js"></script>

<script src="../trees.js"></script>
<script src="ImportPathTree.js"></script>
<script src="NullTree.js"></script>

</head>
<body>
<script>

var ParseTree = traceur.syntax.trees.ParseTree;
var ParseTreeType = traceur.syntax.trees.ParseTreeType;

function testParseTreeType() {
  assertEquals('PROGRAM', ParseTreeType.PROGRAM);
}

function testParseTree() {
  var tree = new ParseTree('type', 'location');
  assertEquals('type', tree.type);
  assertEquals('location', tree.location);
}

function testParseTree2() {
  var tree = new ParseTree(ParseTreeType.NULL, 'location');
  assertEquals(ParseTreeType.NULL, tree.type);
  assertEquals(true, tree.isNull());
  assertEquals(false, tree.isPattern());
}

function validateTree(constr, type, fields) {
  function TestTree() {
    constr.apply(this, fields);
  }

  var tree = new TestTree();
  assertEquals(type, tree.type);

  // Verify that each of the fields has been set to the correct value
  for (var i = 0; i < fields.length; i++) {
    var f = fields[i];
    assertEquals(f, tree[f]);
  }
}

function testNullTree() {
  // NullTree is a singleton so it needs its own test
  var tree = new traceur.syntax.trees.NullTree();
  assertEquals('NULL', tree.type);
  assertEquals(null, tree.location);
  var tree2 = new traceur.syntax.trees.NullTree();
  assertEquals(tree, tree2);
}

function testImportPathTree() {
  // ImportPathTree has different construction logic
  var ImportPathTree = traceur.syntax.trees.ImportPathTree;

  var specifiers = ['importSpecifierSet'];
  var tree = new ImportPathTree('location', 'qualifiedPath', specifiers)
  assertEquals('IMPORT_PATH', tree.type);
  assertEquals('location', tree.location);
  assertEquals('qualifiedPath', tree.qualifiedPath);
  assertEquals(specifiers, tree.importSpecifierSet);
  assertEquals(ImportPathTree.Kind.SET, tree.kind);

  tree = new ImportPathTree('location', 'qualifiedPath', ImportPathTree.Kind.ALL)
  assertEquals('IMPORT_PATH', tree.type);
  assertEquals('location', tree.location);
  assertEquals('qualifiedPath', tree.qualifiedPath);
  assertEquals(null, tree.importSpecifierSet);
  assertEquals(ImportPathTree.Kind.ALL, tree.kind);

  tree = new ImportPathTree('location', 'qualifiedPath', ImportPathTree.Kind.NONE)
  assertEquals('IMPORT_PATH', tree.type);
  assertEquals('location', tree.location);
  assertEquals('qualifiedPath', tree.qualifiedPath);
  assertEquals(null, tree.importSpecifierSet);
  assertEquals(ImportPathTree.Kind.NONE, tree.kind);
}

function testTreeConstructors() {
  validateTree(traceur.syntax.trees.ArgumentListTree,
      ParseTreeType.ARGUMENT_LIST,
      ['location', 'args']);

  validateTree(traceur.syntax.trees.ArrayLiteralExpressionTree,
      ParseTreeType.ARRAY_LITERAL_EXPRESSION,
      ['location', 'elements']);

  validateTree(traceur.syntax.trees.ArrayPatternTree,
      ParseTreeType.ARRAY_PATTERN,
      ['location', 'elements']);

  validateTree(traceur.syntax.trees.AsyncStatementTree,
      ParseTreeType.ASYNC_STATEMENT,
      ['location', 'identifier', 'expression']);

  validateTree(traceur.syntax.trees.BinaryOperatorTree,
      ParseTreeType.BINARY_OPERATOR,
      ['location', 'left', 'operator', 'right']);

  validateTree(traceur.syntax.trees.BlockTree,
      ParseTreeType.BLOCK,
      ['location', 'statements']);

  validateTree(traceur.syntax.trees.BreakStatementTree,
      ParseTreeType.BREAK_STATEMENT,
      ['location', 'name']);

  validateTree(traceur.syntax.trees.CallExpressionTree,
      ParseTreeType.CALL_EXPRESSION,
      ['location', 'operand', 'args']);

  validateTree(traceur.syntax.trees.CaseClauseTree,
      ParseTreeType.CASE_CLAUSE,
      ['location', 'expression', 'statements']);

  validateTree(traceur.syntax.trees.CatchTree,
      ParseTreeType.CATCH,
      ['location', 'exceptionName', 'catchBody']);

  validateTree(traceur.syntax.trees.ClassDeclarationTree,
      ParseTreeType.CLASS_DECLARATION,
      ['location', 'name', 'superClass', 'elements']);

  validateTree(traceur.syntax.trees.ClassExpressionTree,
      ParseTreeType.CLASS_EXPRESSION,
      ['location']);

  validateTree(traceur.syntax.trees.CommaExpressionTree,
      ParseTreeType.COMMA_EXPRESSION,
      ['location', 'expressions']);

  validateTree(traceur.syntax.trees.ConditionalExpressionTree,
      ParseTreeType.CONDITIONAL_EXPRESSION,
      ['location', 'condition', 'left', 'right']);

  validateTree(traceur.syntax.trees.ContinueStatementTree,
      ParseTreeType.CONTINUE_STATEMENT,
      ['location', 'name']);

  validateTree(traceur.syntax.trees.DebuggerStatementTree,
      ParseTreeType.DEBUGGER_STATEMENT,
      ['location']);

  validateTree(traceur.syntax.trees.DefaultClauseTree,
      ParseTreeType.DEFAULT_CLAUSE,
      ['location', 'statements']);

  validateTree(traceur.syntax.trees.DefaultParameterTree,
      ParseTreeType.DEFAULT_PARAMETER,
      ['location', 'identifier', 'expression']);

  validateTree(traceur.syntax.trees.DoWhileStatementTree,
      ParseTreeType.DO_WHILE_STATEMENT,
      ['location', 'body', 'condition']);

  validateTree(traceur.syntax.trees.EmptyStatementTree,
      ParseTreeType.EMPTY_STATEMENT,
      ['location']);

  validateTree(traceur.syntax.trees.ExportDeclarationTree,
      ParseTreeType.EXPORT_DECLARATION,
      ['location', 'declaration']);

  validateTree(traceur.syntax.trees.ExpressionStatementTree,
      ParseTreeType.EXPRESSION_STATEMENT,
      ['location', 'expression']);

  validateTree(traceur.syntax.trees.FieldDeclarationTree,
      ParseTreeType.FIELD_DECLARATION,
      ['location', 'isStatic', 'isConst', 'declarations']);

  validateTree(traceur.syntax.trees.FinallyTree,
      ParseTreeType.FINALLY,
      ['location', 'block']);

  validateTree(traceur.syntax.trees.ForEachStatementTree,
      ParseTreeType.FOR_EACH_STATEMENT,
      ['location', 'initializer', 'collection', 'body']);

  validateTree(traceur.syntax.trees.ForInStatementTree,
      ParseTreeType.FOR_IN_STATEMENT,
      ['location', 'initializer', 'collection', 'body']);

  validateTree(traceur.syntax.trees.FormalParameterListTree,
      ParseTreeType.FORMAL_PARAMETER_LIST,
      ['location', 'parameters']);

  validateTree(traceur.syntax.trees.ForStatementTree,
      ParseTreeType.FOR_STATEMENT,
      ['location', 'initializer', 'condition', 'increment', 'body']);

  validateTree(traceur.syntax.trees.FunctionDeclarationTree,
      ParseTreeType.FUNCTION_DECLARATION,
      ['location', 'name', 'isStatic', 'formalParameterList', 'functionBody']);

  validateTree(traceur.syntax.trees.GetAccessorTree,
      ParseTreeType.GET_ACCESSOR,
      ['location', 'propertyName', 'isStatic', 'body']);

  validateTree(traceur.syntax.trees.IdentifierExpressionTree,
      ParseTreeType.IDENTIFIER_EXPRESSION,
      ['location', 'identifierToken']);

  validateTree(traceur.syntax.trees.IfStatementTree,
      ParseTreeType.IF_STATEMENT,
      ['location', 'condition', 'ifClause', 'elseClause']);

  validateTree(traceur.syntax.trees.ImportDeclarationTree,
      ParseTreeType.IMPORT_DECLARATION,
      ['location', 'importPathList']);

  validateTree(traceur.syntax.trees.ImportSpecifierTree,
      ParseTreeType.IMPORT_SPECIFIER,
      ['location', 'importedName', 'destinationName']);

  validateTree(traceur.syntax.trees.LabelledStatementTree,
      ParseTreeType.LABELLED_STATEMENT,
      ['location', 'name', 'statement']);

  validateTree(traceur.syntax.trees.LiteralExpressionTree,
      ParseTreeType.LITERAL_EXPRESSION,
      ['location', 'literalToken']);

  validateTree(traceur.syntax.trees.MemberExpressionTree,
      ParseTreeType.MEMBER_EXPRESSION,
      ['location', 'operand', 'memberName']);

  validateTree(traceur.syntax.trees.MemberLookupExpressionTree,
      ParseTreeType.MEMBER_LOOKUP_EXPRESSION,
      ['location', 'operand', 'memberExpression']);

  validateTree(traceur.syntax.trees.MissingPrimaryExpressionTree,
      ParseTreeType.MISSING_PRIMARY_EXPRESSION,
      ['location', 'nextToken']);

  validateTree(traceur.syntax.trees.MixinResolveListTree,
      ParseTreeType.MIXIN_RESOLVE_LIST,
      ['location', 'resolves']);

  validateTree(traceur.syntax.trees.MixinResolveTree,
      ParseTreeType.MIXIN_RESOLVE,
      ['location', 'from', 'to']);

  validateTree(traceur.syntax.trees.MixinTree,
      ParseTreeType.MIXIN,
      ['location', 'name', 'mixinResolves']);

  validateTree(traceur.syntax.trees.ModuleDefinitionTree,
      ParseTreeType.MODULE_DEFINITION,
      ['location', 'name', 'elements']);

  validateTree(traceur.syntax.trees.NewExpressionTree,
      ParseTreeType.NEW_EXPRESSION,
      ['location', 'operand', 'args']);

  validateTree(traceur.syntax.trees.ObjectLiteralExpressionTree,
      ParseTreeType.OBJECT_LITERAL_EXPRESSION,
      ['location', 'propertyNameAndValues']);

  validateTree(traceur.syntax.trees.ObjectPatternFieldTree,
      ParseTreeType.OBJECT_PATTERN_FIELD,
      ['location', 'identifier', 'element']);

  validateTree(traceur.syntax.trees.ObjectPatternTree,
      ParseTreeType.OBJECT_PATTERN,
      ['location', 'fields']);

  validateTree(traceur.syntax.trees.ParenExpressionTree,
      ParseTreeType.PAREN_EXPRESSION,
      ['location', 'expression']);

  validateTree(traceur.syntax.trees.PostfixExpressionTree,
      ParseTreeType.POSTFIX_EXPRESSION,
      ['location', 'operand', 'operator']);

  validateTree(traceur.syntax.trees.ProgramTree,
      ParseTreeType.PROGRAM,
      ['location', 'sourceElements']);

  validateTree(traceur.syntax.trees.PropertyNameAssignmentTree,
      ParseTreeType.PROPERTY_NAME_ASSIGNMENT,
      ['location', 'name', 'value']);

  validateTree(traceur.syntax.trees.RequiresMemberTree,
      ParseTreeType.REQUIRES_MEMBER,
      ['location', 'name']);

  validateTree(traceur.syntax.trees.RestParameterTree,
      ParseTreeType.REST_PARAMETER,
      ['location', 'identifier']);

  validateTree(traceur.syntax.trees.ReturnStatementTree,
      ParseTreeType.RETURN_STATEMENT,
      ['location', 'expression']);

  validateTree(traceur.syntax.trees.SetAccessorTree,
      ParseTreeType.SET_ACCESSOR,
      ['location', 'propertyName', 'isStatic', 'parameter', 'body']);

  validateTree(traceur.syntax.trees.SpreadExpressionTree,
      ParseTreeType.SPREAD_EXPRESSION,
      ['location', 'expression']);

  validateTree(traceur.syntax.trees.SpreadPatternElementTree,
      ParseTreeType.SPREAD_PATTERN_ELEMENT,
      ['location', 'lvalue']);

  validateTree(traceur.syntax.trees.SuperExpressionTree,
      ParseTreeType.SUPER_EXPRESSION,
      ['location']);

  validateTree(traceur.syntax.trees.SwitchStatementTree,
      ParseTreeType.SWITCH_STATEMENT,
      ['location', 'expression', 'caseClauses']);

  validateTree(traceur.syntax.trees.ThisExpressionTree,
      ParseTreeType.THIS_EXPRESSION,
      ['location']);

  validateTree(traceur.syntax.trees.ThrowStatementTree,
      ParseTreeType.THROW_STATEMENT,
      ['location', 'value']);

  validateTree(traceur.syntax.trees.TraitDeclarationTree,
      ParseTreeType.TRAIT_DECLARATION,
      ['location', 'name', 'elements']);

  validateTree(traceur.syntax.trees.TryStatementTree,
      ParseTreeType.TRY_STATEMENT,
      ['location', 'body', 'catchBlock', 'finallyBlock']);

  validateTree(traceur.syntax.trees.UnaryExpressionTree,
      ParseTreeType.UNARY_EXPRESSION,
      ['location', 'operator', 'operand']);

  validateTree(traceur.syntax.trees.VariableDeclarationListTree,
      ParseTreeType.VARIABLE_DECLARATION_LIST,
      ['location', 'declarationType', 'declarations']);

  validateTree(traceur.syntax.trees.VariableDeclarationTree,
      ParseTreeType.VARIABLE_DECLARATION,
      ['location', 'lvalue', 'initializer']);

  validateTree(traceur.syntax.trees.VariableStatementTree,
      ParseTreeType.VARIABLE_STATEMENT,
      ['location', 'declarations']);

  validateTree(traceur.syntax.trees.WhileStatementTree,
      ParseTreeType.WHILE_STATEMENT,
      ['location', 'condition', 'body']);

  validateTree(traceur.syntax.trees.WithStatementTree,
      ParseTreeType.WITH_STATEMENT,
      ['location', 'expression', 'body']);

  validateTree(traceur.syntax.trees.YieldStatementTree,
      ParseTreeType.YIELD_STATEMENT,
      ['location', 'expression']);
}

</script>
</body>
</html>
